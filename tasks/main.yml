---
- name: Determine if dotmodules.repo is a local path
  set_fact:
    dotmodules_repo_local: "{{ dotmodules.repo is match('^(file://|/).*') }}"

- name: Remove file:// prefix if present
  set_fact:
    dotmodules_repo_path: "{{ dotmodules.repo | regex_replace('^file://', '') }}"
  when: dotmodules_repo_local

- name: Clone or update dotmodules repository (remote)
  ansible.builtin.git:
    repo: "{{ dotmodules.repo }}"
    dest: "{{ dotmodules.dest }}"
    version: "main"
    force: yes
  when: not dotmodules_repo_local

- name: Link dotmodules folder (for testing)
  ansible.builtin.file:
    src: "{{ dotmodules_repo_path }}"
    dest: "{{ dotmodules.dest }}"
    state: link
  when: dotmodules_repo_local

# Initialize aggregated configurations
- name: Initialize aggregated module configurations
  ansible.builtin.set_fact:
    stow_dirs: []
    collected_configs: {}

- name: Process each dotmodule in the install list
  ansible.builtin.include_tasks: process_module.yml
  loop: "{{ dotmodules.install }}"
  loop_control:
    loop_var: module_name

# Convert collected_configs to a list of key-value pairs
- name: Convert collected configurations to key-value pairs
  ansible.builtin.set_fact:
    collected_items: >-
      {{
        collected_configs | dict2items
        | map(attribute='value') | list
        | map('dict2items') | sum(start=[])
      }}

# Deduplicate list-based values and detect conflicts for scalar values
- name: Reduce collected configurations
  ansible.builtin.set_fact:
    final_config: >-
      {{
        final_config | default({}) | combine({
          item.key: (
            ((final_config | default({}))[item.key] | default([]) + item.value) | flatten | unique
            if item.value is iterable and item.value is not string and item.value is not mapping
            else item.value
          )
        }, recursive=True)
      }}
  loop: "{{ collected_items }}"

# Fail if there are conflicting scalar values
- name: Detect conflicts in scalar values
  ansible.builtin.fail:
    msg: "Conflicting values detected for key(s): {{ ansible_failed_task }}"
  when: ansible_failed_task is defined and ansible_failed_task | length > 0

- name: Debug final_config contents
  ansible.builtin.debug:
    var: ansible_facts

# Set reasonable defaults
- name: Override geerling.mac defaults
  ansible.builtin.set_fact:
    homebrew_taps: []
    mas_installed_apps: []

# Promote each variable from the combined config into a host variable
- name: Set combined facts
  ansible.builtin.set_fact:
    "{{ item.key }}": "{{ item.value }}"
  loop: "{{ final_config | dict2items }}"

# Resolve file strategy conflicts first
- name: Resolve file strategy conflicts
  ansible.builtin.include_tasks: conflict_resolution.yml
  when: dotmodules.install | length > 0

# Handle mergeable files
- name: Process mergeable files
  ansible.builtin.include_tasks: merge_files.yml
  when: dotmodules.install | length > 0

# Filter out modules that have mergeable files to prevent conflicts
- name: Create list of modules with mergeable files
  ansible.builtin.set_fact:
<<<<<<< HEAD
    modules_with_mergeable_files: []

- name: Check each module for mergeable files
  ansible.builtin.set_fact:
    modules_with_mergeable_files: >-
      {{
        modules_with_mergeable_files +
        ([item] if (collected_configs[item].mergeable_files is defined and
                    collected_configs[item].mergeable_files | length > 0)
         else [])
      }}
  loop: "{{ dotmodules.install }}"
  when: item in collected_configs
=======
    modules_with_mergeable_files: "{{ modules_with_mergeable_files | default([]) + [item] }}"
  loop: "{{ dotmodules.install }}"
  when: >
    item in collected_configs
    and collected_configs[item].mergeable_files is defined
    and collected_configs[item].mergeable_files | length > 0
>>>>>>> 5c3e36f (Refactor: Replace geerlingguy.mac.homebrew with direct Ansible modules)

- name: Debug filtering results
  ansible.builtin.debug:
    msg: |
      Filtering results:
      - Original stow_dirs: {{ stow_dirs }}
      - Modules with mergeable files: {{ modules_with_mergeable_files }}
      - Collected configs keys: {{ collected_configs.keys() | list }}

- name: Filter stow directories to exclude modules with mergeable files
  ansible.builtin.set_fact:
    stow_dirs_filtered: "{{ stow_dirs | difference(modules_with_mergeable_files) }}"

- name: Debug final filtering results
  ansible.builtin.debug:
    msg: |
      Final filtering results:
      - Filtered stow_dirs: {{ stow_dirs_filtered }}

# Run Stow once for all modules (excluding those with mergeable files)
- name: Deploy all dotfiles using stow (non-mergeable files only)
  ansible.builtin.command: >-
    stow --adopt -d "{{ dotmodules.dest }}/{{ item }}" -t "{{ ansible_env.HOME }}" files
  loop: "{{ stow_dirs_filtered }}"
  when: stow_dirs_filtered | length > 0

# Run Homebrew installation once for all modules
- name: Run Mac App Store installation for all modules using the collection
  ansible.builtin.include_role:
    name: "geerlingguy.mac.mas"
  when: >
    final_config | dict2items
    | selectattr('key', 'match', '^mas_')
    | list | length > 0

# Run Homebrew installation using direct modules (no sudo required)
- name: Ensure configured Homebrew taps are tapped
  community.general.homebrew_tap:
    tap: "{{ item }}"
    state: present
  loop: "{{ homebrew_taps | default([]) }}"
  when: homebrew_taps is defined and homebrew_taps | length > 0

- name: Ensure configured Homebrew packages are installed
  community.general.homebrew:
    name: "{{ item }}"
    state: present
  loop: "{{ homebrew_packages | default([]) }}"
  when: homebrew_packages is defined and homebrew_packages | length > 0

- name: Install configured Homebrew casks
  community.general.homebrew_cask:
    name: "{{ item }}"
    state: present
    accept_external_apps: yes
  loop: "{{ homebrew_casks | default([]) }}"
  when: homebrew_casks is defined and homebrew_casks | length > 0
